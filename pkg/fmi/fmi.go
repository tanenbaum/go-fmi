package fmi

// #include <stdlib.h>
// #include "./c/fmi2Functions.h"
// #include "bridge.h"
// typedef const fmi2CallbackFunctions* fmi2CallbackFunctions_t;
// typedef const fmi2String* strings_t;
// typedef const fmi2ValueReference* valueReferences_t;
// typedef const fmi2Real* fmi2Reals_t;
// typedef const fmi2Integer* fmi2Integers_t;
// typedef const fmi2Boolean* fmi2Booleans_t;
// typedef const fmi2String* fmi2Strings_t;
// typedef const fmi2Byte* serializedState_t;
// typedef const fmi2StatusKind fmi2StatusKind_t;
import "C"
import (
	"errors"
	"fmt"
	"reflect"
	"unsafe"
)

var (
	fmiVersion       = C.CString(C.fmi2Version)
	fmiTypesPlatform = C.CString(C.fmi2TypesPlatform)
	// fmus stores all active FMUs at runtime
	fmus = map[FMUID]*FMU{}
	// models stores registered models
	models = map[string]Model{}
)

// FMUID holds a simple pointer that can be shared from this library to the calling system
// The id is mapped internally to the actual FMU stored in Go memory
type FMUID uintptr

func (f FMUID) asFMI2Component() C.fmi2Component {
	return C.fmi2Component(f)
}

// RegisterModel registers a model implementation and description with this FMI implementation.
// Multiple separate models can be registered, as long as they have different GUIDs.
// When Instantiated, the model will be looked up by GUID in the generated modelDescription.xml file in the FMI.
func RegisterModel(model Model) error {
	desc := model.Description()
	if desc.GUID == "" {
		return errors.New("Model description GUID cannot be empty")
	}

	if _, got := models[desc.GUID]; got {
		return fmt.Errorf("Model for GUID %s already registered", desc.GUID)
	}

	models[desc.GUID] = model
	return nil
}

//export fmi2GetVersion
func fmi2GetVersion() C.fmi2String {
	return fmiVersion
}

// GetVersion is wrapper for fmi2GetVersion
func GetVersion() string {
	return C.GoString(fmi2GetVersion())
}

//export fmi2GetTypesPlatform
func fmi2GetTypesPlatform() C.fmi2String {
	return fmiTypesPlatform
}

// GetTypesPlatform is wrapper for fmi2GetTypesPlatform
func GetTypesPlatform() string {
	return C.GoString(fmi2GetTypesPlatform())
}

func fmuBool(b C.fmi2Boolean) bool {
	return b == C.fmi2True
}

func boolFMU(b bool) C.fmi2Boolean {
	if b {
		return C.fmi2True
	}
	return C.fmi2False
}

//export fmi2Instantiate
/*
fmi2Instantiate returns a new instance of an FMU. If a null pointer is returned, then instantiation
failed. In that case, `functions->logger` is called with detailed information about the
reason. An FMU can be instantiated many times (provided capability flag canBeInstantiatedOnlyOncePerProcess = false).

This function must be called successfully before any of the following functions can be called.
For co-simulation, this function call has to perform all actions of a slave which are necessary
before a simulation run starts (for example, loading the model file, compilation...).

Argument `instanceName` is a unique identifier for the FMU instance. It is used to name the
instance, for example, in error or information messages generated by one of the fmi2XXXFunctional Mock-up Interface 2.0.2
functions. It is not allowed to provide a null pointer and this string must be non-empty (in
other words, must have at least one character that is no white space). [If only one FMU is
simulated, as instanceName attribute modelName or <ModelExchange/CoSimulation modelIdentifier=”..”> from the XML schema fmiModelDescription might be used.]

Argument `fmuType` defines the type of the FMU:

- fmi2ModelExchange : FMU with initialization and events; between events simulation
of continuous systems is performed with external integrators from the environment

- fmi2CoSimulation : Black box interface for co-simulation.

Argument `fmuGUID` is used to check that the modelDescription.xml file is compatible with the C code of the FMU.
It is a vendor specific globally unique identifier of the
XML file (for example, it is a “fingerprint” of the relevant information stored in the XML file). It
is stored in the XML file as attribute “guid” and has to be passed to the
fmi2Instantiate function via argument fmuGUID. It must be identical to the one stored
inside the fmi2Instantiate function; otherwise the C code and the XML file of the FMU
are not consistent with each other. This argument cannot be null.

Argument fmuResourceLocation is a URI according to the IETF RFC3986 syntax to
indicate the location to the "resources" directory of the unzipped FMU archive.
[Function fmi2Instantiate is then able to read all
needed resources from this directory, for example maps or tables used by the FMU.]

Argument `functions` provides callback functions to be used from the FMU functions to
utilize resources from the environment. Only logging is implemented here.
Memory management callbacks will be removed in FMI v3.0.

Argument visible = fmi2False defines that the interaction with the user should be
reduced to a minimum (no application window, no plotting, no animation, etc.). In other
words, the FMU is executed in batch mode. If visible = fmi2True , the FMU is executed
in interactive mode, and the FMU might require to explicitly acknowledge start of simulation /
instantiation / initialization (acknowledgment is non-blocking).
`visible` is ignored by this implementation.

If loggingOn = fmi2True , debug logging is enabled. If loggingOn = fmi2False , debug
logging is disabled. [The FMU enable/disables LogCategories which are useful for
debugging according to this argument. Which LogCategories the FMU sets is unspecified.]
*/
func fmi2Instantiate(instanceName C.fmi2String, fmuType C.fmi2Type, fmuGUID C.fmi2String,
	fmuResourceLocation C.fmi2String, functions C.fmi2CallbackFunctions_t,
	_ C.fmi2Boolean, loggingOn C.fmi2Boolean) C.fmi2Component {
	id := FMUID(len(fmus))
	fmu := &FMU{
		Name:             C.GoString(instanceName),
		Typee:            FMUType(fmuType),
		GUID:             C.GoString(fmuGUID),
		ResourceLocation: C.GoString(fmuResourceLocation),
		State:            ModelStateInstantiated,
	}
	// log errors by default
	loggingMask := loggerCategoryError
	// loggingOn means log events
	if fmuBool(loggingOn) {
		loggingMask |= loggerCategoryEvents
	}
	fmu.logger = &logger{
		mask: loggingMask,
		fmiCallbackLogger: func(status Status, category, message string) {
			n := C.CString(fmu.Name)
			c := C.CString(category)
			m := C.CString(message)
			defer C.free(unsafe.Pointer(n))
			defer C.free(unsafe.Pointer(c))
			defer C.free(unsafe.Pointer(m))
			C.bridge_fmi2CallbackLogger(functions.logger, functions.componentEnvironment, n, C.fmi2Status(status), c, m)
		},
	}

	if fmu.Name == "" {
		fmu.logger.Error(errors.New("Missing instance name"))
		return nil
	}

	if fmu.GUID == "" {
		fmu.logger.Error(errors.New("Missing GUID"))
		return nil
	}

	_, ok := models[fmu.GUID]
	if !ok {
		fmu.logger.Error(fmt.Errorf("GUID %s does not match any registered model", fmu.GUID))
		return nil
	}

	fmus[id] = fmu

	return C.fmi2Component(id)
}

// Instantiate is Go wrapper for fmi2Instantiate
// callback functions use a default value
func Instantiate(instanceName string, fmuType FMUType, fmuGUID string,
	fmuResourceLocation string, visible bool, loggingOn bool) FMUID {
	n := C.CString(instanceName)
	g := C.CString(fmuGUID)
	r := C.CString(fmuResourceLocation)
	comp := fmi2Instantiate(n, C.fmi2Type(fmuType), g, r, &C.fmi2CallbackFunctions{}, boolFMU(visible), boolFMU(loggingOn))
	C.free(unsafe.Pointer(n))
	C.free(unsafe.Pointer(g))
	C.free(unsafe.Pointer(r))
	return FMUID(comp)
}

//export fmi2FreeInstance
/*
fmi2FreeInstance disposes the given instance, unloads the loaded model, and frees all the allocated memory
and other resources that have been allocated by the functions of the FMU interface. If a null
pointer is provided for `c`, the function call is ignored (does not have an effect).
*/
func fmi2FreeInstance(c C.fmi2Component) {
	if c == nil {
		return
	}

	id, _, err := getFMU(c)
	if err != nil {
		return
	}

	delete(fmus, id)
	C.free(unsafe.Pointer(id))
}

// FreeInstance is a wrapper for fmi2FreeInstance
func FreeInstance(id FMUID) {
	fmi2FreeInstance(C.fmi2Component(id))
}

//export fmi2SetDebugLogging
/*
fmi2SetDebugLogging controls debug logging that is output via the logger function callback.
If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.
If loggingOn = fmi2True and nCategories = 0, then all debug messages shall be output.
If loggingOn=fmi2True and nCategories > 0, then only debug messages according to
the categories argument shall be output. Vector categories has
nCategories elements. The allowed values of categories are defined by the modeling
environment that generated the FMU. Depending on the generating modeling environment,
none, some or all allowed values for categories for this FMU are defined in the
modelDescription.xml file via element `fmiModelDescription.LogCategories `.
Supported log categories are in `logger.go`.
*/
func fmi2SetDebugLogging(c C.fmi2Component, loggingOn C.fmi2Boolean,
	nCategories C.size_t, categories C.strings_t) C.fmi2Status {
	const expected = ModelStateInstantiated | ModelStateInitializationMode |
		ModelStateEventMode | ModelStateContinuousTimeMode |
		ModelStateStepComplete | ModelStateStepInProgress | ModelStateStepFailed | ModelStateStepCanceled |
		ModelStateTerminated | ModelStateError
	fmu, ok := allowedState(c, "SetDebugLogging", expected)
	if !ok {
		return C.fmi2Error
	}
	if !fmuBool(loggingOn) {
		fmu.logger.setMask(loggerCategoryNone)
		return C.fmi2OK
	}
	if nCategories == 0 {
		fmu.logger.setMask(loggerCategoryAll)
		return C.fmi2OK
	}
	var cs []C.fmi2String
	carrayToSlice(unsafe.Pointer(categories), unsafe.Pointer(&cs), int(nCategories))
	mask := loggerCategoryNone
	for _, c := range cs {
		cat := C.GoString(c)
		m, err := loggerCategoryFromString(cat)
		if err != nil {
			fmu.logger.Error(fmt.Errorf("Log category %s was not recognized", cat))
		}
		mask |= m
	}
	fmu.logger.setMask(mask)
	return C.fmi2OK
}

//export fmi2SetupExperiment
func fmi2SetupExperiment(c C.fmi2Component, toleranceDefined C.fmi2Boolean,
	tolerance C.fmi2Real, startTime C.fmi2Real, stopTimeDefined C.fmi2Boolean,
	stopTime C.fmi2Real) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2EnterInitializationMode
func fmi2EnterInitializationMode(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2ExitInitializationMode
func fmi2ExitInitializationMode(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2Terminate
func fmi2Terminate(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2Reset
func fmi2Reset(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetReal
func fmi2GetReal(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value *C.fmi2Real) C.fmi2Status {
	// TODO: implement
	var vs []C.fmi2Real
	carrayToSlice(unsafe.Pointer(value), unsafe.Pointer(&vs), int(nvr))
	for i := 0; i < int(nvr); i++ {
		vs[i] = 1.0
	}
	return C.fmi2OK
}

//export fmi2GetInteger
func fmi2GetInteger(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value *C.fmi2Integer) C.fmi2Status {
	// TODO: implement
	var vs []C.fmi2Integer
	carrayToSlice(unsafe.Pointer(value), unsafe.Pointer(&vs), int(nvr))
	for i := 0; i < int(nvr); i++ {
		vs[i] = 1
	}
	return C.fmi2OK
}

//export fmi2GetBoolean
func fmi2GetBoolean(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value *C.fmi2Boolean) C.fmi2Status {
	// TODO: implement
	var vs []C.fmi2Boolean
	carrayToSlice(unsafe.Pointer(value), unsafe.Pointer(&vs), int(nvr))
	for i := 0; i < int(nvr); i++ {
		vs[i] = 1
	}
	return C.fmi2OK
}

//export fmi2GetString
func fmi2GetString(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value *C.fmi2String) C.fmi2Status {
	// TODO: implement
	var vs []C.fmi2String
	carrayToSlice(unsafe.Pointer(value), unsafe.Pointer(&vs), int(nvr))
	for i := 0; i < int(nvr); i++ {
		vs[i] = C.CString("foo")
	}
	return C.fmi2OK
}

//export fmi2SetReal
func fmi2SetReal(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value C.fmi2Reals_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetInteger
func fmi2SetInteger(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value C.fmi2Integers_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetBoolean
func fmi2SetBoolean(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value C.fmi2Booleans_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetString
func fmi2SetString(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, value C.fmi2Strings_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetFMUstate
func fmi2GetFMUstate(c C.fmi2Component, FMUstate *C.fmi2FMUstate) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetFMUstate
func fmi2SetFMUstate(c C.fmi2Component, FMUState C.fmi2FMUstate) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2FreeFMUstate
func fmi2FreeFMUstate(c C.fmi2Component, FMUState *C.fmi2FMUstate) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SerializedFMUstateSize
func fmi2SerializedFMUstateSize(c C.fmi2Component, FMUState C.fmi2FMUstate, size *C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SerializeFMUstate
func fmi2SerializeFMUstate(c C.fmi2Component, FMUstate C.fmi2FMUstate, serializedState *C.fmi2Byte, size C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2DeSerializeFMUstate
func fmi2DeSerializeFMUstate(c C.fmi2Component, serializedState C.serializedState_t, size C.size_t, FMUstate *C.fmi2FMUstate) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetDirectionalDerivative
func fmi2GetDirectionalDerivative(c C.fmi2Component, vUnknown_ref C.valueReferences_t, nUnknown C.size_t,
	vKnown_ref C.valueReferences_t, nKnown C.size_t,
	dvKnown C.fmi2Reals_t, dvUnknown *C.fmi2Real) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2EnterEventMode
func fmi2EnterEventMode(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2NewDiscreteStates
func fmi2NewDiscreteStates(c C.fmi2Component, fmi2eventInfo *C.fmi2EventInfo) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2EnterContinuousTimeMode
func fmi2EnterContinuousTimeMode(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2CompletedIntegratorStep
func fmi2CompletedIntegratorStep(c C.fmi2Component, noSetFMUStatePriorToCurrentPoint C.fmi2Boolean, enterEventMode, terminateSimulation *C.fmi2Boolean) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetTime
func fmi2SetTime(c C.fmi2Component, time C.fmi2Real) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetContinuousStates
func fmi2SetContinuousStates(c C.fmi2Component, x C.fmi2Reals_t, nx C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetDerivatives
func fmi2GetDerivatives(c C.fmi2Component, derivatives *C.fmi2Real, nx C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetEventIndicators
func fmi2GetEventIndicators(c C.fmi2Component, eventIndicators *C.fmi2Real, ni C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetContinuousStates
func fmi2GetContinuousStates(c C.fmi2Component, x *C.fmi2Real, nx C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetNominalsOfContinuousStates
func fmi2GetNominalsOfContinuousStates(c C.fmi2Component, x_nominal *C.fmi2Real, nx C.size_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2SetRealInputDerivatives
func fmi2SetRealInputDerivatives(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, order C.fmi2Integers_t, value C.fmi2Reals_t) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetRealOutputDerivatives
func fmi2GetRealOutputDerivatives(c C.fmi2Component, vr C.valueReferences_t, nvr C.size_t, order C.fmi2Integers_t, value *C.fmi2Real) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2DoStep
func fmi2DoStep(c C.fmi2Component, currentCommunicationPoint, communicationStepSize C.fmi2Real, noSetFMUStatePriorToCurrentPoint C.fmi2Boolean) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2CancelStep
func fmi2CancelStep(c C.fmi2Component) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetStatus
func fmi2GetStatus(c C.fmi2Component, s C.fmi2StatusKind, value *C.fmi2Status) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetRealStatus
func fmi2GetRealStatus(c C.fmi2Component, s C.fmi2StatusKind, value *C.fmi2Real) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetIntegerStatus
func fmi2GetIntegerStatus(c C.fmi2Component, s C.fmi2StatusKind, value *C.fmi2Integer) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetBooleanStatus
func fmi2GetBooleanStatus(c C.fmi2Component, s C.fmi2StatusKind, value *C.fmi2Boolean) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

//export fmi2GetStringStatus
func fmi2GetStringStatus(c C.fmi2Component, s C.fmi2StatusKind, value *C.fmi2String) C.fmi2Status {
	// TODO: implement
	return C.fmi2OK
}

func getFMU(c C.fmi2Component) (id FMUID, fmu *FMU, err error) {
	id = FMUID(c)
	fmu, err = GetFMU(id)
	return
}

func GetFMU(id FMUID) (*FMU, error) {
	fmu, ok := fmus[id]
	if !ok {
		return nil, fmt.Errorf("FMU %v not found", id)
	}
	return fmu, nil
}

func allowedState(c C.fmi2Component, name string, expected ModelState) (*FMU, bool) {
	_, fmu, err := getFMU(c)
	if err != nil {
		return nil, false
	}

	if fmu.State&expected == 0 {
		fmu.logger.Error(fmt.Errorf("Illegal call sequence at %s", name))
		return nil, false
	}
	return fmu, true
}

func carrayToSlice(carray unsafe.Pointer, slice unsafe.Pointer, len int) {
	sliceHeader := (*reflect.SliceHeader)(slice)
	sliceHeader.Cap = len
	sliceHeader.Len = len
	sliceHeader.Data = uintptr(carray)
}
